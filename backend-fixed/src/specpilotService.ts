import { openai } from "./aiClient.js";

export interface CanonicalSpec {
  metadata: {
    title: string;
    description: string;
    summary?: string;
    version: string;
    created_at: string;
  };
  events: CanonicalEvent[];
  destinations: string[];
  acceptance_criteria: string[];
  open_questions: string[];
}

export interface CanonicalEvent {
  name: string;
  description: string;
  trigger: string;
  properties: CanonicalProperty[];
  identity: {
    primary: string | null;
    secondary: string[];
  };
  business_rules: string[];
  technical_rules: string[];
  validation?: {
    overall_score?: number;
  };
}

export interface CanonicalProperty {
  name: string;
  type: string;
  required: boolean;
  description: string;
  pii?: {
    classification: string;
  };
}

const SYSTEM_PROMPT = `You are SpecPilot, an expert at transforming vague tracking requirements into structured CDP specifications.

When given a tracking request, you should:
1. Identify all relevant events in the user journey (typically 3-6 events)
2. Define clear properties for each event
3. Identify PII fields and their classifications
4. Create acceptance criteria
5. List any open questions for clarification

Always return well-structured, implementation-ready specifications.`;

const CANONICAL_SYSTEM_PROMPT = `You are SpecPilot, an expert at creating canonical CDP specifications in JSON format.

Return a JSON object with this exact structure:
{
  "metadata": {
    "title": "string",
    "description": "string",          // what the spec covers
    "summary": "string",              // short 1-2 sentence summary
    "version": "1.0.0",
    "created_at": "ISO date string"
  },
  "events": [
    {
      "name": "Event Name",                     // concise, Title Case (max 4 words)
      "description": "What this event captures",
      "trigger": "When this event fires",
      "properties": [
        {
          "name": "property_name",
          "type": "string|number|boolean|object|array",
          "required": true|false,
          "description": "What this property captures",
          "pii": { "classification": "none|low|medium|high" }
        }
      ],
      "identity": {
        "primary": "user_id or null",
        "secondary": ["email", "phone"]
      },
      "business_rules": ["Rule 1", "Rule 2"],
      "technical_rules": ["Rule 1", "Rule 2"],
      "validation": { "overall_score": 80 }     // 0-100
    }
  ],
  "destinations": ["segment", "tealium", "mparticle"],   // lowercase slugs
  "acceptance_criteria": ["Criterion 1", "Criterion 2"],
  "open_questions": ["Question 1", "Question 2"]
}

Rules:
- Generate 3-6 events that cover the end-to-end user journey.
- Use concise, implementation-ready names and triggers (event names max 4 words, Title Case).
- Every event must have at least 3 properties and at least 1 required property.
- Provide at least 2 acceptance_criteria and at least 2 open_questions.
- Destinations must be lowercase slugs from: segment, tealium, mparticle, salesforce, adobe (choose at least two).
- Return ONLY valid JSON (no markdown, no code fences).`;

// Helper to enforce minimal completeness so the UI doesnâ€™t show blanks
export function normalizeCanonicalSpec(input: any): CanonicalSpec {
  const meta = input?.metadata || {};
  const events = Array.isArray(input?.events) ? input.events : [];
  const destinations = Array.isArray(input?.destinations) ? input.destinations : [];
  const acceptance = Array.isArray(input?.acceptance_criteria) ? input.acceptance_criteria : [];
  const questions = Array.isArray(input?.open_questions) ? input.open_questions : [];

  const safeDestinations =
    destinations.length > 0
      ? destinations.map((d: any) => String(d || "").toLowerCase().replace(/\s+/g, ""))
      : ["segment", "tealium", "mparticle"];

  const normalizedEvents = events.map((evt: any, idx: number) => {
    const props = Array.isArray(evt?.properties) ? evt.properties : [];
    return {
      name: (evt?.name || `Event ${idx + 1}`).trim(),
      description: evt?.description || "Event generated by SpecPilot.",
      trigger: evt?.trigger || "When this event fires in the user journey.",
      properties: props.map((p: any) => ({
        name: p?.name || "property_name",
        type: (p?.type || "string").toLowerCase(),
        required: !!p?.required,
        description: p?.description || "",
        pii: p?.pii,
      })),
      identity: {
        primary: evt?.identity?.primary || null,
        secondary: Array.isArray(evt?.identity?.secondary) ? evt.identity.secondary : [],
      },
      business_rules: Array.isArray(evt?.business_rules) ? evt.business_rules : [],
      technical_rules: Array.isArray(evt?.technical_rules) ? evt.technical_rules : [],
      validation: {
        overall_score: evt?.validation?.overall_score ?? 95,
      },
    };
  });

  return {
    metadata: {
      title: meta.title || "Untitled Spec",
      description: meta.description || "Tracking specification based on intake request.",
      summary: meta.summary || meta.description || meta.title || "Tracking specification based on intake request.",
      version: meta.version || "1.0.0",
      created_at: meta.created_at || new Date().toISOString(),
    },
    events: normalizedEvents,
    destinations: safeDestinations,
    acceptance_criteria:
      acceptance.length >= 2 ? acceptance : ["All required fields present", "PII handled with consent"],
    open_questions:
      questions.length >= 2 ? questions : ["Any edge cases to track?", "Should guest flows be handled differently?"],
  };
}

export async function generateSpecFromIntake(input: string): Promise<string> {
  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [
      { role: "system", content: SYSTEM_PROMPT },
      {
        role: "user",
        content: `Create a detailed tracking specification for: ${input}

Format as markdown with these sections:
# Event Specification: [Title]

## Overview
[Description of what we're tracking]

## Events

### Event 1: [Event Name]
- **Trigger:** When this event fires
- **Description:** What this event captures

#### Properties
| Property | Type | Required | Description | PII |
|----------|------|----------|-------------|-----|
| property_name | string | Yes | Description | None |

#### Business Rules
- Rule 1
- Rule 2

---

## Destinations
- Destination 1
- Destination 2

## Acceptance Criteria
- [ ] Criterion 1
- [ ] Criterion 2

## Open Questions
- Question 1?
- Question 2?`,
      },
    ],
    temperature: 0.7,
    max_tokens: 4000,
  });

  return response.choices[0]?.message?.content || "";
}

export async function generateCanonicalSpecFromIntake(input: string): Promise<CanonicalSpec> {
  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [
      { role: "system", content: CANONICAL_SYSTEM_PROMPT },
      {
        role: "user",
        content: `Create a canonical tracking specification for: ${input}

Generate 3-6 events covering the complete user journey. Return only valid JSON.`,
      },
    ],
    temperature: 0.7,
    max_tokens: 4000,
  });

  const content = response.choices[0]?.message?.content || "{}";
  
  // Clean up potential markdown code blocks
  let cleaned = content.trim();
  if (cleaned.startsWith("```json")) {
    cleaned = cleaned.slice(7);
  } else if (cleaned.startsWith("```")) {
    cleaned = cleaned.slice(3);
  }
  if (cleaned.endsWith("```")) {
    cleaned = cleaned.slice(0, -3);
  }
  cleaned = cleaned.trim();

  try {
    const parsed = JSON.parse(cleaned);
    return normalizeCanonicalSpec(parsed);
  } catch (err) {
    console.error("Failed to parse canonical spec:", err);
    // Return a minimal valid spec
    return normalizeCanonicalSpec({
      metadata: {
        title: "Parsing Error",
        description: "Failed to parse AI response",
        version: "1.0.0",
        created_at: new Date().toISOString(),
      },
      events: [],
      destinations: [],
      acceptance_criteria: [],
      open_questions: ["AI response could not be parsed. Please try again."],
    });
  }
}
