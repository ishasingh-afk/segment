/**
 * Tealium iQ / EventStream / AudienceStream Adapter
 * Transforms canonical spec to Tealium-compatible format
 */

interface CanonicalSpec {
  metadata?: {
    title?: string;
    summary?: string;
    submitted_at?: string;
  };
  events?: Array<{
    name: string;
    description?: string;
    trigger?: string;
    properties?: Array<{
      name: string;
      type: string;
      required?: boolean;
      description?: string;
      pii?: { classification?: string };
    }>;
    identity?: {
      primary?: string;
      secondary?: string[];
    };
    business_rules?: string[];
    technical_rules?: string[];
  }>;
  destinations?: Array<{
    name: string;
    requirements?: string[];
  }>;
  acceptance_criteria?: string[];
}

export function transformToTealiumCdp(canonical: CanonicalSpec): any {
  const events = canonical.events || [];
  const timestamp = new Date().toISOString();

  // Helper to convert to Tealium attribute naming (camelCase)
  const toTealiumAttr = (name: string): string => {
    return name.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  };

  // Helper to map types to Tealium data types
  const toTealiumType = (type: string): string => {
    const typeMap: Record<string, string> = {
      string: "string",
      number: "number",
      boolean: "boolean",
      array: "array_of_strings",
      object: "string", // JSON stringified
      integer: "number",
    };
    return typeMap[type?.toLowerCase()] || "string";
  };

  // Helper to determine data layer scope
  const getScope = (piiLevel?: string): string => {
    if (piiLevel === "high" || piiLevel === "medium") return "visitor";
    return "event";
  };

  return {
    // Tealium Profile metadata
    profile: {
      name: canonical.metadata?.title?.replace(/\s+/g, "_").toLowerCase() || "tracking_profile",
      display_name: canonical.metadata?.title || "Tracking Profile",
      description: canonical.metadata?.summary || "Generated by SpecPilot",
      created_at: timestamp,
      version: "1.0",
    },

    // Data Layer specification
    data_layer: {
      description: "Universal Data Object (UDO) specification",
      attributes: events.flatMap((event) =>
        (event.properties || []).map((prop) => ({
          name: toTealiumAttr(prop.name),
          source_name: prop.name, // Original snake_case name
          type: toTealiumType(prop.type),
          scope: getScope(prop.pii?.classification),
          description: prop.description || "",
          required: prop.required || false,
          pii: prop.pii?.classification !== "none" && prop.pii?.classification !== undefined,
          enrichment: prop.pii?.classification === "high" ? "hash_sha256" : null,
        }))
      ),
    },

    // EventStream Events
    event_specs: events.map((event, index) => {
      const eventName = event.name.replace(/\s+/g, "_").toLowerCase();
      
      return {
        event_name: eventName,
        display_name: event.name,
        description: event.description || "",
        trigger: event.trigger || "",
        
        // Tealium EventStream format
        event_feed: {
          name: `ef_${eventName}`,
          event_type: "link", // or "view" for page views
          condition: {
            attribute: "tealium_event",
            operator: "equals",
            value: eventName,
          },
        },

        // Required attributes for this event
        required_attributes: (event.properties || [])
          .filter((p) => p.required)
          .map((p) => toTealiumAttr(p.name)),

        // All attributes with specs
        attributes: (event.properties || []).map((prop) => ({
          name: toTealiumAttr(prop.name),
          udo_variable: `data.${prop.name}`,
          type: toTealiumType(prop.type),
          required: prop.required || false,
          description: prop.description || "",
          validation: prop.type === "string" ? { max_length: 255 } : {},
        })),

        // Identity configuration
        visitor_id: {
          primary: event.identity?.primary 
            ? toTealiumAttr(event.identity.primary)
            : "tealium_visitor_id",
          secondary: (event.identity?.secondary || []).map(toTealiumAttr),
        },
      };
    }),

    // AudienceStream Attributes (for visitor stitching)
    audience_stream: {
      visitor_attributes: events.flatMap((event) =>
        (event.properties || [])
          .filter((p) => p.pii?.classification === "low" || p.pii?.classification === "medium")
          .map((prop) => ({
            name: toTealiumAttr(prop.name),
            type: "current_value", // or "badge", "metric", "timeline"
            source: "event_attribute",
            source_attribute: toTealiumAttr(prop.name),
            enrichment: null,
          }))
      ),
      
      // Visitor identity
      visitor_id_attributes: [
        {
          name: "primary_id",
          type: "id",
          source: events[0]?.identity?.primary || "user_id",
          priority: 1,
        },
        ...(events[0]?.identity?.secondary || []).map((id, idx) => ({
          name: id,
          type: "id",
          source: id,
          priority: idx + 2,
        })),
      ],
    },

    // Connector configurations (destinations)
    connectors: (canonical.destinations || []).map((dest, index) => ({
      id: `connector_${index + 1}`,
      name: dest.name,
      type: mapToTealiumConnector(dest.name),
      enabled: true,
      trigger: "all_events", // or specific event names
      configuration: {
        requirements: dest.requirements || [],
      },
    })),

    // Tag Management configuration
    tag_management: {
      tags: events.map((event) => ({
        name: `Tag: ${event.name}`,
        template: "Tealium Generic Tag",
        load_rules: [
          {
            condition: "tealium_event",
            operator: "equals",
            value: event.name.replace(/\s+/g, "_").toLowerCase(),
          },
        ],
        data_mappings: (event.properties || []).map((prop) => ({
          source: `data.${prop.name}`,
          destination: toTealiumAttr(prop.name),
        })),
      })),
    },

    // Validation rules
    validation: {
      business_rules: events.flatMap((e) => e.business_rules || []),
      technical_rules: events.flatMap((e) => e.technical_rules || []),
    },

    // Metadata
    _metadata: {
      generatedBy: "SpecPilot Tealium Adapter",
      generatedAt: timestamp,
      sourceSpec: canonical.metadata?.title || "Untitled",
      tealiumVersion: "2024.1",
    },
  };
}

// Helper to map destination names to Tealium connector types
function mapToTealiumConnector(destName: string): string {
  const name = destName.toLowerCase();
  
  if (name.includes("google") && name.includes("analytics")) return "google_analytics_4";
  if (name.includes("facebook")) return "facebook_conversions_api";
  if (name.includes("amplitude")) return "amplitude";
  if (name.includes("mixpanel")) return "mixpanel";
  if (name.includes("salesforce")) return "salesforce_marketing_cloud";
  if (name.includes("hubspot")) return "hubspot";
  if (name.includes("bigquery")) return "google_bigquery";
  if (name.includes("snowflake")) return "snowflake";
  if (name.includes("s3") || name.includes("aws")) return "amazon_s3";
  if (name.includes("webhook")) return "webhook";
  
  return "custom_connector";
}