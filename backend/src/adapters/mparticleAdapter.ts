/**
 * mParticle Data Plan Adapter
 * Transforms canonical spec to mParticle Data Plan format
 */

interface CanonicalSpec {
  metadata?: {
    title?: string;
    summary?: string;
    submitted_at?: string;
  };
  events?: Array<{
    name: string;
    description?: string;
    trigger?: string;
    properties?: Array<{
      name: string;
      type: string;
      required?: boolean;
      description?: string;
      pii?: { classification?: string };
      consent?: { required?: boolean };
    }>;
    identity?: {
      primary?: string;
      secondary?: string[];
    };
    business_rules?: string[];
    technical_rules?: string[];
  }>;
  destinations?: Array<{
    name: string;
    requirements?: string[];
  }>;
  acceptance_criteria?: string[];
}

export function transformToMParticleCdp(canonical: CanonicalSpec): any {
  const events = canonical.events || [];
  const timestamp = new Date().toISOString();

  // Helper to convert event name to mParticle format (lowercase with underscores)
  const toMpEventName = (name: string): string => {
    return name.toLowerCase().replace(/\s+/g, "_");
  };

  // Helper to map types to mParticle/JSON Schema types
  const toMpType = (type: string): string => {
    const typeMap: Record<string, string> = {
      string: "string",
      number: "number",
      boolean: "boolean",
      array: "array",
      object: "object",
      integer: "integer",
    };
    return typeMap[type?.toLowerCase()] || "string";
  };

  // Helper to determine mParticle event type
  const getMpEventType = (eventName: string): string => {
    const name = eventName.toLowerCase();
    if (name.includes("purchase") || name.includes("order")) return "commerce_event";
    if (name.includes("screen") || name.includes("page")) return "screen_view";
    if (name.includes("session")) return "session_start";
    return "custom_event";
  };

  // Helper to get custom event type
  const getCustomEventType = (eventName: string): string => {
    const name = eventName.toLowerCase();
    if (name.includes("search")) return "Search";
    if (name.includes("click") || name.includes("tap")) return "Navigation";
    if (name.includes("share") || name.includes("social")) return "Social";
    if (name.includes("add") || name.includes("cart") || name.includes("purchase")) return "Transaction";
    if (name.includes("view") || name.includes("impression")) return "Content";
    return "Other";
  };

  return {
    // mParticle Data Plan format
    data_plan_id: canonical.metadata?.title?.replace(/\s+/g, "_").toLowerCase() || "data_plan",
    data_plan_name: canonical.metadata?.title || "Data Plan",
    data_plan_description: canonical.metadata?.summary || "Generated by SpecPilot",
    data_plan_versions: [
      {
        version: 1,
        version_description: "Initial version",
        activated_environment: "development",
        created_on: timestamp,
        last_modified_on: timestamp,
        
        // Data Plan Document
        version_document: {
          data_points: events.map((event) => {
            const mpEventType = getMpEventType(event.name);
            const mpEventName = toMpEventName(event.name);

            return {
              description: event.description || "",
              match: {
                type: mpEventType,
                criteria: {
                  event_name: mpEventName,
                  custom_event_type: mpEventType === "custom_event" 
                    ? getCustomEventType(event.name) 
                    : undefined,
                },
              },
              
              // JSON Schema validator for event attributes
              validator: {
                type: "json_schema",
                definition: {
                  $schema: "http://json-schema.org/draft-07/schema#",
                  type: "object",
                  properties: {
                    data: {
                      type: "object",
                      properties: {
                        custom_attributes: {
                          type: "object",
                          properties: Object.fromEntries(
                            (event.properties || []).map((prop) => [
                              prop.name,
                              {
                                type: toMpType(prop.type),
                                description: prop.description || "",
                              },
                            ])
                          ),
                          required: (event.properties || [])
                            .filter((p) => p.required)
                            .map((p) => p.name),
                          additionalProperties: false,
                        },
                      },
                    },
                  },
                },
              },
            };
          }),

          // Settings
          settings: {
            validation_actions: {
              event: {
                unplanned: "allow", // or "drop", "flag"
              },
              event_attribute: {
                unplanned: "allow",
                missing_required: "flag",
                invalid_type: "flag",
              },
              user_attribute: {
                unplanned: "allow",
              },
            },
          },
        },
      },
    ],

    // Event schemas (additional detail)
    event_schemas: events.map((event) => ({
      event_name: toMpEventName(event.name),
      display_name: event.name,
      event_type: getMpEventType(event.name),
      custom_event_type: getMpEventType(event.name) === "custom_event" 
        ? getCustomEventType(event.name) 
        : null,
      description: event.description || "",
      trigger: event.trigger || "",

      // Attributes
      attributes: (event.properties || []).map((prop) => ({
        name: prop.name,
        data_type: toMpType(prop.type),
        required: prop.required || false,
        description: prop.description || "",
        is_pii: prop.pii?.classification !== "none" && prop.pii?.classification !== undefined,
        pii_type: mapPiiToMParticle(prop.pii?.classification),
        consent_required: prop.consent?.required || false,
      })),

      // Business rules
      validation_rules: event.business_rules || [],
    })),

    // User Attribute schemas
    user_attributes: extractUserAttributes(events),

    // Identity configuration
    identity_config: {
      identity_priority: [
        { type: "customer_id", priority: 1 },
        { type: "email", priority: 2 },
        { type: "other", priority: 3, value: events[0]?.identity?.primary || "user_id" },
        ...(events[0]?.identity?.secondary || []).map((id, idx) => ({
          type: "other",
          priority: idx + 4,
          value: id,
        })),
      ],
      
      // IDSync configuration
      id_sync: {
        strategy: "profile_conversion",
        allow_login_identity_changes: true,
      },
    },

    // Output integrations (kits/connections)
    integrations: (canonical.destinations || []).map((dest, index) => ({
      id: index + 1,
      name: dest.name,
      kit_name: mapToMParticleKit(dest.name),
      enabled: true,
      event_filtering: {
        type: "include_all",
        events: [],
      },
      attribute_filtering: {
        type: "include_all",
        attributes: [],
      },
      configuration: {
        requirements: dest.requirements || [],
      },
    })),

    // Data privacy / GDPR configuration
    data_privacy: {
      gdpr_consent_state: {
        purpose: "data_processing",
        consented: false, // Require explicit consent
        timestamp_ms: Date.now(),
      },
      ccpa_consent_state: {
        data_sale_opt_out: false,
        timestamp_ms: Date.now(),
      },
    },

    // Metadata
    _metadata: {
      generatedBy: "SpecPilot mParticle Adapter",
      generatedAt: timestamp,
      sourceSpec: canonical.metadata?.title || "Untitled",
      mParticleVersion: "2.0",
      sdkVersion: "8.x",
    },
  };
}

// Helper to extract user attributes from events
function extractUserAttributes(events: any[]): any[] {
  const userAttrs: any[] = [];
  const seen = new Set<string>();

  events.forEach((event) => {
    (event.properties || [])
      .filter((p: any) => 
        p.pii?.classification === "low" || 
        p.name.includes("user") ||
        p.name.includes("customer")
      )
      .forEach((prop: any) => {
        if (!seen.has(prop.name)) {
          seen.add(prop.name);
          userAttrs.push({
            name: prop.name,
            data_type: prop.type,
            description: prop.description || "",
            is_required: false,
          });
        }
      });
  });

  return userAttrs;
}

// Helper to map PII classification to mParticle PII type
function mapPiiToMParticle(classification?: string): string | null {
  const map: Record<string, string> = {
    high: "pii",
    medium: "quasi_pii",
    low: "pseudonymous",
    none: null as any,
  };
  return map[classification || "none"] || null;
}

// Helper to map destination names to mParticle kit names
function mapToMParticleKit(destName: string): string {
  const name = destName.toLowerCase();

  if (name.includes("google") && name.includes("analytics")) return "GoogleAnalyticsFirebase";
  if (name.includes("firebase")) return "GoogleAnalyticsFirebase";
  if (name.includes("facebook")) return "Facebook";
  if (name.includes("amplitude")) return "Amplitude";
  if (name.includes("mixpanel")) return "Mixpanel";
  if (name.includes("braze")) return "Braze";
  if (name.includes("appsflyer")) return "AppsFlyer";
  if (name.includes("adjust")) return "Adjust";
  if (name.includes("segment")) return "Segment";
  if (name.includes("salesforce")) return "Salesforce";
  if (name.includes("hubspot")) return "HubSpot";
  if (name.includes("intercom")) return "Intercom";
  if (name.includes("leanplum")) return "Leanplum";

  return "Custom";
}